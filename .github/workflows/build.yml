name: OpenList Alpine x86_64 编译
on:
  push:
  pull_request:
  workflow_dispatch:
    inputs:
      debug_enabled:
        type: boolean
        default: false
        description: '启用调试模式'
jobs:
  compile-openlist:
    runs-on: ubuntu-latest
    container: alpine:3.23
    steps:
      - name: 初始化环境
        run: |
          apk update && apk add --no-cache git file coreutils
          mkdir -p /app /build

      - name: 拉取源码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 安装Go编译环境
        run: |
          apk add --no-cache go gcc g++ musl-dev linux-headers
          go version
          go env

      - name: 查看目录结构
        run: |
          echo "当前目录: $(pwd)"
          echo "目录内容:"
          ls -la
          echo "查找Go项目:"
          find . -name "go.mod" -o -name "*.go" | head -20

      - name: 编译OpenList
        run: |
          # 使用GitHub Actions的标准工作目录
          WORKDIR="$GITHUB_WORKSPACE"
          echo "工作目录: $WORKDIR"
          cd "$WORKDIR"
          
          # 设置Go环境
          go env -w GOPROXY=https://goproxy.cn,direct
          go env -w GOSUMDB=off
          
          # 检查项目结构
          echo "项目结构:"
          ls -la
          
          # 查找main.go或go.mod
          if [ -f "go.mod" ]; then
            echo "找到go.mod文件"
            cat go.mod | head -5
            
            # 查找入口点
            if [ -f "main.go" ]; then
              ENTRY="."
              echo "使用main.go作为入口"
            elif [ -d "cmd" ]; then
              # 查找cmd目录下的第一个可执行文件
              for dir in cmd/*/; do
                if [ -d "$dir" ] && [ -f "${dir}main.go" ]; then
                  ENTRY="./${dir%/}"
                  echo "使用入口: $ENTRY"
                  break
                fi
              done
            else
              # 尝试查找包含main函数的go文件
              ENTRY=$(find . -name "*.go" -type f -exec grep -l "func main()" {} \; | head -1)
              if [ -n "$ENTRY" ]; then
                ENTRY=$(dirname "$ENTRY")
                echo "找到main函数在: $ENTRY"
              fi
            fi
            
            if [ -n "$ENTRY" ]; then
              echo "开始编译..."
              CGO_ENABLED=1 GOOS=linux GOARCH=amd64 \
              go build -trimpath -ldflags="-s -w -extldflags '-static' -buildvcs=false" \
              -o /app/openlist-alpine-x86_64 "$ENTRY"
            else
              echo "::warning::未找到明确入口，尝试编译整个模块..."
              CGO_ENABLED=1 GOOS=linux GOARCH=amd64 \
              go build -trimpath -ldflags="-s -w -extldflags '-static' -buildvcs=false" \
              -o /app/openlist-alpine-x86_64 ./...
            fi
          else
            echo "::error::未找到go.mod文件"
            exit 1
          fi
          
          # 验证编译结果
          if [ -f "/app/openlist-alpine-x86_64" ]; then
            chmod +x /app/openlist-alpine-x86_64
            echo "编译成功！"
            file /app/openlist-alpine-x86_64
            ls -lh /app/openlist-alpine-x86_64
          else
            echo "::warning::编译未生成可执行文件，尝试其他方式..."
            # 尝试直接编译所有go文件
            CGO_ENABLED=1 GOOS=linux GOARCH=amd64 \
            go build -trimpath -ldflags="-s -w -extldflags '-static' -buildvcs=false" \
            -o /app/openlist-alpine-x86_64 .
            
            if [ -f "/app/openlist-alpine-x86_64" ]; then
              chmod +x /app/openlist-alpine-x86_64
              echo "备用编译方式成功！"
              file /app/openlist-alpine-x86_64
            fi
          fi

      - name: 调试模式
        if: github.event_name == 'workflow_dispatch' && inputs.debug_enabled == true
        run: |
          echo "=== 调试信息 ==="
          echo "环境变量:"
          env | grep -E "GITHUB|PATH" | sort
          echo "当前目录: $(pwd)"
          echo "目录树:"
          find . -type f -name "*.go" | head -30
          echo "go.mod内容:"
          if [ -f "go.mod" ]; then cat go.mod; fi

      - name: 产物处理
        run: |
          if [ -f "/app/openlist-alpine-x86_64" ]; then
            echo "处理编译产物..."
            strip /app/openlist-alpine-x86_64 2>/dev/null || true
            
            # 创建包含说明文件的包
            mkdir -p /app-dist
            cp /app/openlist-alpine-x86_64 /app-dist/
            echo "OpenList Alpine x86_64 版本" > /app-dist/README.txt
            echo "编译时间: $(date)" >> /app-dist/README.txt
            echo "文件信息: $(file /app/openlist-alpine-x86_64)" >> /app-dist/README.txt
            
            tar -zcvf /build/openlist-alpine-x86_64-$(date +%Y%m%d-%H%M%S).tar.gz -C /app-dist .
            
            echo "编译成功！"
            echo "产物大小: $(du -h /build/*.tar.gz | cut -f1)"
          else
            echo "::error::编译失败，未生成可执行文件"
            # 列出可能的编译输出
            find /app -type f -name "*" 2>/dev/null || true
            exit 1
          fi

      - name: 上传产物
        uses: actions/upload-artifact@v4
        with:
          name: openlist-alpine-x86_64
          path: /build/*.tar.gz
          retention-days: 7